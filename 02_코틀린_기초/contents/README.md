# 코틀린 기초

- 함수는 fun 키워드 사용
- 함수를 최상위 수준에 정의할 수 있다. 자바와 달리 꼭 클래스 안에 함수를 넣어야할 필요가 없다.
- 배열과 클래스도 마찬가지이다. 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- println() 과 같이 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있도록 `wrapper` 를 제공한다.
- 세미콜론이 필요 없다.

## 변수

- __val : immutable -> 자바의 final 변수__
  - 기본적으로 val 로 선언하고 꼭 필요할 때만 var 로 바꾸는 것이 좋다.
  - 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.
* 
- __var : mutable__

## 패키지

### 자바

- geometry
  - example
    - Main
  - shapes
    - Rectangle
    - RectangleUtil

### 코틀린

- geometry
  - example.kt
  - shapes.kt

> 코틀린에서는 .kt 파일이 자바의 패키지를 의미하기도 한다.

## 스마트 캐스트

- 코틀린에서는 `is` 를 사용해 변수 타입을 검사한다.
- 자바의 instanceof 와 비슷하다. 하지만 자바에서 어떤 변수의 타입을 instanceof 로 확인한 다음에 그 타입에 속한 멤버에 접근하기 위해서 명시적으로 변수 타입을 캐스팅해야 한다.
- 코틀린에서는 프로그래머 대신 컴파일러가 캐스팅을 해준다. 
- 어떤 변수가 원하는 타입인지 일단 is 로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다.
- 하지만, 실제로는 컴파일러가 캐스팅을 수행해주고, 이를 `스마트 캐스트(smart cast)` 라고 부른다.

```kotlin
if (e is Sum) {
  return eval(e.right) + eval(e.left)
}
```

## 이터레이션

- 코틀린은 자바의 for 루프(어떤 변수를 초기화하고 그 변수를 루프를 한 번 실행할 때마다 갱신하고 루프 조건이 거짓이 될 때 반복을 마치는 형태의 루프)에 해당하는 요소가 없다.
- 코틀린에서는 `범위(range)` 를 사용한다.
  - val oneToTen = 1..10
- 이런 식으로 어떤 범위에 속한 값을 일정한 순서로 이터레이션하는 경우를 `수열(progression)`이라고 부른다.

